//! This module handles checking if a node was generated from a proc-macro without marking it's span
//! as coming from one.
//!
//! Proc-macros are capable of setting the span of every token they output to a few possible spans.
//! This includes spans we can detect easily as coming from a proc-macro (e.g. the call site or the
//! def site), and spans we can't easily detect as such (e.g. the span of any token passed into the
//! proc macro). This capability means proc-macros can generate code with a span that looks like it
//! was written by the user, but which should not be linted by clippy as it was generated by an
//! external macro.
//!
//! That brings us to this module. The current approach is to jump to various parts within a node's
//! span and lex the source code looking for a small number of tokens which must exist within the
//! same context to create the node. If at each of these positions the required tokens or the `$`
//! token appear then the node is considered to not be generated by a proc-macro.

use crate::source::{HasSourceMap, SourceRange, SpanExt};
use core::ops::Range;
use rustc_abi::ExternAbi;
use rustc_ast::ast::{
    AttrKind, BoundAsyncness, BoundConstness, BoundPolarity, LitIntType, StrStyle, TraitObjectSyntax,
};
use rustc_ast::token::{CommentKind, Delimiter};
use rustc_ast::{
    self as ast, AttrStyle, BindingMode, BorrowKind, ByRef, CaptureBy, ForLoopKind, GenBlockKind, Label, LitFloatType,
    Mutability, Pinnedness, UnOp,
};
use rustc_hir::HirId;
use rustc_hir::intravisit::FnKind;
use rustc_middle::ty::TyCtxt;
use rustc_middle::ty::layout::HasTyCtxt;
use rustc_span::source_map::Spanned;
use rustc_span::symbol::{Ident, kw};
use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, SyntaxContext};
use {rustc_hir as hir, rustc_lexer as lex};

#[inline]
pub fn is_from_proc_macro<'sm>(sm: impl HasSourceMap<'sm>, node: impl Node) -> bool {
    let sm = sm.source_map();
    let sp = node.span().data();
    sp.get_text(sm)
        .is_none_or(|text| !node.check_text(&mut Cursor::new(&text, sp.lo..sp.hi, sp.ctxt)))
}

#[inline]
pub fn is_fn_kind_from_proc_macro<'tcx>(tcx: &impl HasTyCtxt<'tcx>, _kind: &FnKind<'_>, hir_id: HirId) -> bool {
    fn f(tcx: TyCtxt<'_>, hir_id: HirId) -> bool {
        match tcx.hir_node(hir_id) {
            hir::Node::Expr(e) if let hir::ExprKind::Closure(c) = e.kind => is_from_proc_macro(tcx, c),
            hir::Node::Item(i) => is_from_proc_macro(tcx, i),
            hir::Node::TraitItem(i) => is_from_proc_macro(tcx, i),
            hir::Node::ImplItem(i) => is_from_proc_macro(tcx, i),
            _ => {
                debug_assert!(false, "`{hir_id:?} is not a function");
                true
            },
        }
    }
    f(tcx.tcx(), hir_id)
}

#[inline]
pub fn is_hir_resolved_path_from_proc_macro<'tcx>(
    sm: impl HasSourceMap<'tcx>,
    qself: Option<&hir::Ty<'_>>,
    path: &hir::Path<'_>,
) -> bool {
    let sm = sm.source_map();
    let sp = path.span.data();
    sp.get_text(sm)
        .is_none_or(|text| !Cursor::new(&text, sp.lo..sp.hi, sp.ctxt).read_pat(HirResolvedPath(qself, path)))
}

pub trait Node: Sized + Copy {
    fn span(self) -> Span;
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool;
}

fn hir_qpath_end_sp(qpath: &hir::QPath<'_>) -> Span {
    match *qpath {
        hir::QPath::Resolved(_, path) => path.span,
        hir::QPath::TypeRelative(_, seg) => seg.ident.span,
    }
}

pub struct Cursor<'txt> {
    next: lex::Token,
    pos: u32,
    text: &'txt str,
    src_range: Range<BytePos>,
    ctxt: SyntaxContext,
    inner: lex::Cursor<'txt>,
}
impl<'txt> Cursor<'txt> {
    fn new(text: &'txt str, src_range: Range<BytePos>, ctxt: SyntaxContext) -> Self {
        let mut cursor = Self {
            next: lex::Token {
                kind: lex::TokenKind::Whitespace,
                len: 0,
            },
            pos: 0,
            text,
            src_range,
            ctxt,
            inner: lex::Cursor::new(text, lex::FrontmatterAllowed::No),
        };
        cursor.step();
        cursor
    }

    fn next_text(&self) -> &'txt str {
        self.text
            .get(self.pos as usize..(self.pos + self.next.len) as usize)
            .unwrap_or("")
    }

    fn step_single(&mut self) {
        self.pos += self.next.len;
        self.next = self.inner.advance_token();
    }

    fn step(&mut self) {
        loop {
            self.step_single();
            if !matches!(
                self.next.kind,
                lex::TokenKind::Whitespace
                    | lex::TokenKind::LineComment { doc_style: None }
                    | lex::TokenKind::BlockComment {
                        doc_style: None,
                        terminated: true
                    }
            ) {
                break;
            }
        }
    }

    fn read_pat(&mut self, pat: impl TokenPat) -> bool {
        pat.read_tokens(self) || (!self.ctxt.is_root() && matches!(self.next.kind, lex::TokenKind::Dollar))
    }

    fn skip_sp(&mut self, sp: Span) -> AdjustedCursor<'_, 'txt> {
        let Some(sp) = sp.walk_to_ctxt(self.ctxt) else {
            return AdjustedCursor {
                cursor: self,
                res: CtxtAdjustRes::NoAdjust,
            };
        };
        let range = sp.into_range();
        let start = range.start.0.wrapping_sub(self.src_range.start.0);
        let end = range.end.0.wrapping_sub(self.src_range.start.0);
        let res = if start <= end
            && let Some(text) = self.text.get(end as usize..)
        {
            self.pos = end;
            self.next.len = 0;
            self.inner = lex::Cursor::new(text, lex::FrontmatterAllowed::No);
            self.step();
            CtxtAdjustRes::Adjust
        } else {
            CtxtAdjustRes::Err
        };
        AdjustedCursor { cursor: self, res }
    }

    fn sub_sp_is_other_ctxt_or_text(&self, sp: Span, expected: &str) -> bool {
        let sp = sp.data();
        self.ctxt != sp.ctxt || {
            let start = sp.lo.0.wrapping_sub(self.src_range.start.0) as usize;
            let end = sp.hi.0.wrapping_sub(self.src_range.start.0) as usize;
            self.text.get(start..end).is_some_and(|text| text == expected)
        }
    }
}

#[derive(Clone, Copy)]
enum CtxtAdjustRes {
    NoAdjust,
    Err,
    Adjust,
}
struct AdjustedCursor<'c, 'txt> {
    cursor: &'c mut Cursor<'txt>,
    res: CtxtAdjustRes,
}
impl AdjustedCursor<'_, '_> {
    fn unadjusted_read_tokens(&mut self, pat: impl TokenPat) -> &mut Self {
        if matches!(self.res, CtxtAdjustRes::NoAdjust) && !pat.read_tokens(self.cursor) {
            self.res = CtxtAdjustRes::Err;
        }
        self
    }

    fn unadjusted_or_read_pat(&mut self, pat: impl TokenPat) -> bool {
        match self.res {
            CtxtAdjustRes::NoAdjust => true,
            CtxtAdjustRes::Err => false,
            CtxtAdjustRes::Adjust => self.cursor.read_pat(pat),
        }
    }

    fn adjusted_and_read_tokens(&mut self, pat: impl TokenPat) -> bool {
        match self.res {
            CtxtAdjustRes::NoAdjust | CtxtAdjustRes::Err => false,
            CtxtAdjustRes::Adjust => pat.read_tokens(self.cursor),
        }
    }
}

/// A type which can match some tokens from a cursor.
trait TokenPat: Sized {
    /// Reads tokens from the cursor and checks if the text matches this value.
    ///
    /// The cursor will be left in an implementation defined position, but still set to the same
    /// span.
    #[must_use]
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool;
}

struct Any<T>(T);

macro_rules! tup_token_pat {
    ($(($($name:ident),*),)*) => {$(
        #[allow(non_snake_case, unused)]
        impl<$($name: TokenPat,)*> TokenPat for ($($name,)*) {
            fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
                let ($($name,)*) = self;
                $($name.read_tokens(cursor)&&)* true
            }
        }
        #[allow(non_snake_case, unused)]
        impl<$($name: TokenPat,)*> TokenPat for Any<($($name,)*)> {
            fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
                let Any(($($name,)*)) = self;
                $($name.read_tokens(cursor)||)* false
            }
        }
    )*};
}
tup_token_pat!((A, B), (A, B, C), (A, B, C, D), (A, B, C, D, E), (A, B, C, D, E, F),);

macro_rules! lex_token_pat {
    ($(($name:ident ($($lex:pat),*) $lex_final:pat),)*) => {$(
        struct $name;
        impl TokenPat for $name {
            fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
                $(
                    if !matches!(cursor.next.kind, $lex) {
                        return false;
                    }
                    cursor.step_single();
                )*
                if !matches!(cursor.next.kind, $lex_final) {
                    return false;
                }
                cursor.step();
                true
            }
        }
    )*};
}
lex_token_pat!(
    (And () lex::TokenKind::And),
    (At () lex::TokenKind::At),
    (Bang () lex::TokenKind::Bang),
    (CBracket () lex::TokenKind::CloseBracket),
    (CParen () lex::TokenKind::CloseParen),
    (Colon () lex::TokenKind::Colon),
    (ColonColon (lex::TokenKind::Colon) lex::TokenKind::Colon),
    (Comma () lex::TokenKind::Comma),
    (DocBlockInner () lex::TokenKind::BlockComment { terminated: true, doc_style: Some(lex::DocStyle::Inner) }),
    (DocBlockOuter () lex::TokenKind::BlockComment { terminated: true, doc_style: Some(lex::DocStyle::Outer) }),
    (DocLineInner () lex::TokenKind::LineComment { doc_style: Some(lex::DocStyle::Inner) }),
    (DocLineOuter () lex::TokenKind::LineComment { doc_style: Some(lex::DocStyle::Outer) }),
    (Dollar () lex::TokenKind::Dollar),
    (Dot () lex::TokenKind::Dot),
    (DotDot (lex::TokenKind::Dot) lex::TokenKind::Dot),
    (DotDotEq (lex::TokenKind::Dot, lex::TokenKind::Dot) lex::TokenKind::Eq),
    (Eq () lex::TokenKind::Eq),
    (FatArrow (lex::TokenKind::Eq) lex::TokenKind::Gt),
    (Gt () lex::TokenKind::Gt),
    (Lifetime () lex::TokenKind::Lifetime { .. }),
    (LitStr () lex::TokenKind::Literal {
        kind: lex::LiteralKind::Str { terminated: true } | lex::LiteralKind::RawStr { n_hashes: Some(_) },
        ..
    }),
    (Lt () lex::TokenKind::Lt),
    (Minus () lex::TokenKind::Minus),
    (OBrace () lex::TokenKind::OpenBrace),
    (OBracket () lex::TokenKind::OpenBracket),
    (OParen () lex::TokenKind::OpenParen),
    (Or () lex::TokenKind::Or),
    (Pound () lex::TokenKind::Pound),
    (Question () lex::TokenKind::Question),
    (Semi () lex::TokenKind::Semi),
    (Star () lex::TokenKind::Star),
);

macro_rules! lex_opt_token_pat {
    ($(($name:ident $lex_start:pat $(,$lex_tail:pat)*),)*) => {$(
        struct $name;
        impl TokenPat for $name {
            fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
                if !matches!(cursor.next.kind, $lex_start) {
                    return true;
                }
                $(
                    cursor.step_single();
                    if !matches!(cursor.next.kind, $lex_tail) {
                        return false;
                    }
                )*
                cursor.step();
                true
            }
        }
    )*};
}
lex_opt_token_pat!(
    (OptColon lex::TokenKind::Colon),
    (OptColonColon lex::TokenKind::Colon, lex::TokenKind::Colon),
    (OptComma lex::TokenKind::Comma),
    (OptGt lex::TokenKind::Gt),
    (OptLifetime lex::TokenKind::Lifetime { .. }),
    (OptLitStr lex::TokenKind::Literal {
        kind: lex::LiteralKind::Str { terminated: true } | lex::LiteralKind::RawStr { n_hashes: Some(_) },
        ..
    }),
    (OptLt lex::TokenKind::Lt),
    (OptOr lex::TokenKind::Or),
);

macro_rules! skip_lex_token_pat {
    ($(($name:ident $lex:pat),)*) => {$(
        struct $name;
        impl TokenPat for $name {
            fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
                while matches!(cursor.next.kind, $lex) {
                    cursor.step();
                }
                true
            }
        }
    )*}
}
skip_lex_token_pat!(
    (SkipOParen lex::TokenKind::OpenParen),
    (SkipCParen lex::TokenKind::CloseParen),
);

struct EitherRange;
impl TokenPat for EitherRange {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        cursor.step_single();
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        cursor.step_single();

        if matches!(
            cursor.next.kind,
            lex::TokenKind::Eq
                | lex::TokenKind::Whitespace
                | lex::TokenKind::LineComment { .. }
                | lex::TokenKind::BlockComment { terminated: true, .. }
        ) {
            cursor.step();
        }
        true
    }
}

impl TokenPat for &str {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if cursor.next_text() == self {
            cursor.step();
            true
        } else {
            false
        }
    }
}

#[derive(Clone, Copy)]
struct OptText<'a>(&'a str);
impl TokenPat for OptText<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if cursor.next_text() == self.0 {
            cursor.step();
        }
        true
    }
}

#[derive(Clone, Copy)]
struct AnyIdent;
impl TokenPat for AnyIdent {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if !matches!(cursor.next.kind, lex::TokenKind::Ident | lex::TokenKind::RawIdent) {
            return false;
        }
        cursor.step();
        true
    }
}

impl TokenPat for Ident {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match cursor.next.kind {
            lex::TokenKind::Ident
            | lex::TokenKind::Literal {
                kind:
                    lex::LiteralKind::Int {
                        base: lex::Base::Decimal,
                        empty_int: false,
                    },
                ..
            } if cursor.next_text() == self.as_str() => {},
            lex::TokenKind::RawIdent
                if cursor
                    .text
                    .get((cursor.pos + 2) as usize..(cursor.pos + cursor.next.len) as usize)
                    .unwrap_or("")
                    == self.as_str() => {},
            _ => return false,
        }
        cursor.step();
        true
    }
}

impl<T: TokenPat> TokenPat for Option<T> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        self.is_none_or(|x| x.read_tokens(cursor))
    }
}

impl<'a, T> TokenPat for &'a Spanned<T>
where
    &'a T: TokenPat,
{
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        self.node.read_tokens(cursor)
    }
}

impl TokenPat for UnOp {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let matches = match self {
            Self::Deref => matches!(cursor.next.kind, lex::TokenKind::Star),
            Self::Neg => matches!(cursor.next.kind, lex::TokenKind::Minus),
            Self::Not => matches!(cursor.next.kind, lex::TokenKind::Bang),
        };
        if matches {
            cursor.step();
        }
        true
    }
}

impl TokenPat for Label {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if !matches!(cursor.next.kind, lex::TokenKind::Lifetime { .. })
            && cursor
                .text
                .get((cursor.pos + 1) as usize..(cursor.pos + cursor.next.len) as usize)
                .unwrap_or("")
                == self.ident.name.as_str()
        {
            return false;
        }
        cursor.step();
        true
    }
}

struct LabeledItem(Label);
impl TokenPat for LabeledItem {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.0, Colon).read_tokens(cursor)
    }
}

impl TokenPat for Mutability {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Mut => "mut".read_tokens(cursor),
            Self::Not => true,
        }
    }
}

struct OrConst(Mutability);
impl TokenPat for OrConst {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self.0 {
            Mutability::Not => "const",
            Mutability::Mut => "mut",
        };
        pat.read_tokens(cursor)
    }
}

struct OrConstIf(Mutability, bool);
impl TokenPat for OrConstIf {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self.0 {
            Mutability::Not if self.1 => "const",
            Mutability::Not => return true,
            Mutability::Mut => "mut",
        };
        pat.read_tokens(cursor)
    }
}

impl TokenPat for TraitObjectSyntax {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if matches!(self, Self::Dyn) {
            "dyn".read_tokens(cursor)
        } else {
            true
        }
    }
}

impl TokenPat for BoundConstness {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Never => true,
            Self::Maybe(_) => (OParen, "const", CParen).read_tokens(cursor),
            Self::Always(_) => "const".read_tokens(cursor),
        }
    }
}

impl TokenPat for BoundAsyncness {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Normal => true,
            Self::Async(_) => "async".read_tokens(cursor),
        }
    }
}

impl TokenPat for BoundPolarity {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Positive => true,
            Self::Negative(_) => Bang.read_tokens(cursor),
            Self::Maybe(_) => Question.read_tokens(cursor),
        }
    }
}

impl TokenPat for CaptureBy {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self {
            Self::Ref => return true,
            Self::Use { .. } => "use",
            Self::Value { .. } => "move",
        };
        pat.read_tokens(cursor)
    }
}

impl TokenPat for BorrowKind {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self {
            Self::Ref => return true,
            Self::Raw => "raw",
            Self::Pin => "pin",
        };
        pat.read_tokens(cursor)
    }
}

#[derive(Clone, Copy)]
struct AddrOf(BorrowKind, Mutability);
impl TokenPat for AddrOf {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (
            And,
            self.0,
            OrConstIf(self.1, matches!(self.0, BorrowKind::Pin | BorrowKind::Raw)),
        )
            .read_tokens(cursor)
    }
}

impl TokenPat for Pinnedness {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Not => true,
            Self::Pinned => "pin".read_tokens(cursor),
        }
    }
}

#[derive(Clone, Copy)]
struct OrRef(Pinnedness);
impl TokenPat for OrRef {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self.0 {
            Pinnedness::Not => "ref",
            Pinnedness::Pinned => "pin",
        };
        pat.read_tokens(cursor)
    }
}

impl TokenPat for BindingMode {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        self.1.read_tokens(cursor)
            && match self.0 {
                ByRef::Yes(pin, mutbl) => {
                    (OrRef(pin), OrConstIf(mutbl, matches!(pin, Pinnedness::Pinned))).read_tokens(cursor)
                },
                ByRef::No => true,
            }
    }
}

impl TokenPat for ForLoopKind {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::For => "for".read_tokens(cursor),
            Self::ForAwait => ("for", "await").read_tokens(cursor),
        }
    }
}

impl TokenPat for &GenBlockKind {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (!matches!(*self, GenBlockKind::Async | GenBlockKind::AsyncGen) || "async".read_tokens(cursor))
            && (!matches!(*self, GenBlockKind::Gen | GenBlockKind::AsyncGen) || "gen".read_tokens(cursor))
    }
}

impl TokenPat for ast::token::LitKind {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let matches = match self {
            Self::Bool => matches!(cursor.next.kind, lex::TokenKind::Ident),
            Self::Byte => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::Byte { terminated: true },
                    ..
                }
            ),
            Self::Char => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::Char { terminated: true },
                    ..
                }
            ),
            Self::ByteStr => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::ByteStr { terminated: true },
                    ..
                }
            ),
            Self::ByteStrRaw(hashes) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::RawByteStr { n_hashes: Some(n) },
                    ..
                } if hashes == n
            ),
            Self::CStr => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::CStr { terminated: true },
                    ..
                }
            ),
            Self::CStrRaw(hashes) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::RawCStr { n_hashes: Some(n) },
                    ..
                } if hashes == n
            ),
            Self::Str => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::Str { terminated: true },
                    ..
                }
            ),
            Self::StrRaw(hashes) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::RawStr { n_hashes: Some(n) },
                    ..
                } if hashes == n
            ),
            Self::Integer => {
                matches!(
                    cursor.next.kind,
                    lex::TokenKind::Literal {
                        kind: lex::LiteralKind::Int { empty_int: false, .. },
                        ..
                    }
                )
            },
            Self::Float => {
                matches!(
                    cursor.next.kind,
                    lex::TokenKind::Literal {
                        kind: lex::LiteralKind::Float {
                            empty_exponent: false,
                            ..
                        },
                        ..
                    }
                )
            },
            Self::Err(_) => true,
        };
        if matches {
            cursor.step();
        }
        matches
    }
}

impl TokenPat for &ast::LitKind {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let matches = match *self {
            ast::LitKind::Bool(lit) => {
                let text = cursor.next_text();
                text == if lit { "true" } else { "false" }
            },
            ast::LitKind::Byte(_) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::Byte { terminated: true },
                    ..
                }
            ),
            ast::LitKind::Char(_) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::Char { terminated: true },
                    ..
                }
            ),
            ast::LitKind::ByteStr(_, StrStyle::Cooked) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::ByteStr { terminated: true },
                    ..
                }
            ),
            ast::LitKind::ByteStr(_, StrStyle::Raw(hashes)) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::RawByteStr { n_hashes: Some(n) },
                    ..
                } if hashes == n
            ),
            ast::LitKind::CStr(_, StrStyle::Cooked) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::CStr { terminated: true },
                    ..
                }
            ),
            ast::LitKind::CStr(_, StrStyle::Raw(hashes)) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::RawCStr { n_hashes: Some(n) },
                    ..
                } if hashes == n
            ),
            ast::LitKind::Str(_, StrStyle::Cooked) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::Str { terminated: true },
                    ..
                }
            ),
            ast::LitKind::Str(_, StrStyle::Raw(hashes)) => matches!(
                cursor.next.kind,
                lex::TokenKind::Literal {
                    kind: lex::LiteralKind::RawStr { n_hashes: Some(n) },
                    ..
                } if hashes == n
            ),
            ast::LitKind::Int(_, ty) => {
                matches!(
                    cursor.next.kind,
                    lex::TokenKind::Literal {
                        kind: lex::LiteralKind::Int { empty_int: false, .. },
                        ..
                    }
                ) && cursor.next_text().ends_with(match ty {
                    LitIntType::Unsuffixed => "",
                    LitIntType::Signed(x) => x.name_str(),
                    LitIntType::Unsigned(x) => x.name_str(),
                })
            },
            ast::LitKind::Float(_, ty) => {
                matches!(
                    cursor.next.kind,
                    lex::TokenKind::Literal {
                        kind: lex::LiteralKind::Int { empty_int: false, .. }
                            | lex::LiteralKind::Float {
                                empty_exponent: false,
                                ..
                            },
                        ..
                    }
                ) && cursor.next_text().ends_with(match ty {
                    LitFloatType::Unsuffixed => "",
                    LitFloatType::Suffixed(x) => x.name_str(),
                })
            },
            ast::LitKind::Err(_) => true,
        };
        if matches {
            cursor.step();
        }
        matches
    }
}

#[derive(Clone, Copy)]
struct OptAttrStart(AttrStyle);
impl TokenPat for OptAttrStart {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        !Pound.read_tokens(cursor)
            || (matches!(self.0, AttrStyle::Inner).then_some(Bang).read_tokens(cursor) && OBracket.read_tokens(cursor))
    }
}

#[derive(Clone, Copy)]
struct AttrSafety(ast::Safety);
impl TokenPat for AttrSafety {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self.0 {
            ast::Safety::Safe(_) => "safe",
            ast::Safety::Unsafe(_) => "unsafe",
            ast::Safety::Default => return true,
        };
        (pat, OParen).read_tokens(cursor)
    }
}

impl TokenPat for &ast::AttrArgs {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            ast::AttrArgs::Empty => true,
            ast::AttrArgs::Eq { .. } => Eq.read_tokens(cursor),
            ast::AttrArgs::Delimited(args) => match args.delim {
                Delimiter::Brace => OBrace.read_tokens(cursor),
                Delimiter::Bracket => OBracket.read_tokens(cursor),
                Delimiter::Parenthesis => OParen.read_tokens(cursor),
                Delimiter::Invisible(_) => true,
            },
        }
    }
}

impl TokenPat for ast::BlockCheckMode {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Default | Self::Unsafe(ast::UnsafeSource::CompilerGenerated) => true,
            Self::Unsafe(ast::UnsafeSource::UserProvided) => "unsafe".read_tokens(cursor),
        }
    }
}

impl TokenPat for hir::BlockCheckMode {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::DefaultBlock | Self::UnsafeBlock(hir::UnsafeSource::CompilerGenerated) => true,
            Self::UnsafeBlock(hir::UnsafeSource::UserProvided) => "unsafe".read_tokens(cursor),
        }
    }
}

impl TokenPat for ast::Safety {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self {
            Self::Safe(_) => "safe",
            Self::Unsafe(_) => "unsafe",
            Self::Default => return true,
        };
        pat.read_tokens(cursor)
    }
}

impl TokenPat for hir::Safety {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let (pat, res) = match self {
            Self::Safe => ("safe", true),
            Self::Unsafe => ("unsafe", false),
        };
        pat.read_tokens(cursor) | res
    }
}

impl TokenPat for hir::HeaderSafety {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let safety = match self {
            Self::SafeTargetFeatures => hir::Safety::Safe,
            Self::Normal(safety) => safety,
        };
        safety.read_tokens(cursor)
    }
}

impl TokenPat for &ast::Extern {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let pat = match self {
            ast::Extern::None => return true,
            ast::Extern::Explicit(..) => ("extern", Some(LitStr)),
            ast::Extern::Implicit(..) => ("extern", None),
        };
        pat.read_tokens(cursor)
    }
}

struct OptExtern<'a>(&'a ExternAbi);
impl TokenPat for OptExtern<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match ("extern".read_tokens(cursor), self.0) {
            (false, ExternAbi::Rust) => true,
            (false, _) => false,
            (true, _) => OptLitStr.read_tokens(cursor),
        }
    }
}

impl TokenPat for ast::Defaultness {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Final => true,
            Self::Default(..) => "default".read_tokens(cursor),
        }
    }
}

impl TokenPat for hir::Defaultness {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Final => true,
            Self::Default { .. } => "default".read_tokens(cursor),
        }
    }
}

impl TokenPat for ast::Const {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Yes(_) => "const".read_tokens(cursor),
            Self::No => true,
        }
    }
}

impl TokenPat for hir::Constness {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Const => "const".read_tokens(cursor),
            Self::NotConst => true,
        }
    }
}

impl TokenPat for hir::IsAsync {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::NotAsync => true,
            Self::Async(_) => "async".read_tokens(cursor),
        }
    }
}

impl TokenPat for ast::CoroutineKind {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (!matches!(self, Self::Async { .. } | Self::AsyncGen { .. }) || "async".read_tokens(cursor))
            && (!matches!(self, Self::Gen { .. } | Self::AsyncGen { .. }) || "gen".read_tokens(cursor))
    }
}

impl TokenPat for hir::CoroutineDesugaring {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (!matches!(self, Self::Async | Self::AsyncGen) || "async".read_tokens(cursor))
            && (!matches!(self, Self::Gen | Self::AsyncGen) || "gen".read_tokens(cursor))
    }
}

impl TokenPat for hir::ClosureKind {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::Closure | Self::Coroutine(_) => true,
            Self::CoroutineClosure(kind) => kind.read_tokens(cursor),
        }
    }
}

impl TokenPat for &ast::ClosureBinder {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match *self {
            ast::ClosureBinder::For { span, .. } => {
                if !("for", Lt).read_tokens(cursor) {
                    return false;
                }
                match cursor.skip_sp(span).res {
                    CtxtAdjustRes::Err => false,
                    CtxtAdjustRes::NoAdjust | CtxtAdjustRes::Adjust => true,
                }
            },
            ast::ClosureBinder::NotPresent => true,
        }
    }
}

impl TokenPat for hir::ClosureBinder {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            Self::For { span } => {
                if !("for", Lt).read_tokens(cursor) {
                    return false;
                }
                match cursor.skip_sp(span).res {
                    CtxtAdjustRes::Err => false,
                    CtxtAdjustRes::NoAdjust | CtxtAdjustRes::Adjust => true,
                }
            },
            Self::Default => true,
        }
    }
}

impl TokenPat for &ast::TraitBoundModifiers {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.constness, self.asyncness, self.polarity).read_tokens(cursor)
    }
}

impl TokenPat for &hir::TraitBoundModifiers {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.constness, self.polarity).read_tokens(cursor)
    }
}

impl TokenPat for &ast::PathSegment {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        self.ident.read_tokens(cursor)
            && self.args.as_ref().is_none_or(|args| {
                if args.is_angle_bracketed() {
                    (OptColonColon, Lt).read_tokens(cursor)
                } else {
                    OParen.read_tokens(cursor)
                }
            })
    }
}

impl TokenPat for &hir::PathSegment<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.ident.read_tokens(cursor) || (self.ident.name == kw::SelfUpper && "self".read_tokens(cursor)))
            && self.args.is_none_or(|args| {
                if matches!(args.parenthesized, hir::GenericArgsParentheses::No) {
                    (OptColonColon, Lt).read_tokens(cursor)
                } else {
                    OParen.read_tokens(cursor)
                }
            })
    }
}

struct AstSegments<'a>(&'a [ast::PathSegment]);
impl TokenPat for AstSegments<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let mut iter = self.0.iter();
        let Some(mut seg) = iter.next() else {
            return true;
        };
        loop {
            if !seg.read_tokens(cursor) {
                return false;
            }
            if seg.args.is_none()
                && let Some(next) = iter.next()
            {
                if !ColonColon.read_tokens(cursor) {
                    return false;
                }
                seg = next;
            } else {
                return true;
            }
        }
    }
}

struct AstRootableSegments<'a>(&'a [ast::PathSegment]);
impl TokenPat for AstRootableSegments<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let segs = if let [first, rest @ ..] = self.0
            && first.ident.name == kw::PathRoot
        {
            if !ColonColon.read_tokens(cursor) {
                return false;
            }
            rest
        } else {
            self.0
        };
        AstSegments(segs).read_tokens(cursor)
    }
}

impl TokenPat for &ast::Path {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        AstRootableSegments(&self.segments).read_tokens(cursor)
    }
}

struct HirSegments<'a>(&'a [hir::PathSegment<'a>]);
impl TokenPat for HirSegments<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let mut iter = self.0.iter();
        let Some(mut seg) = iter.next() else {
            return true;
        };
        loop {
            if !seg.read_tokens(cursor) {
                return false;
            }
            if seg.args.is_none()
                && let Some(next) = iter.next()
            {
                if !ColonColon.read_tokens(cursor) {
                    return false;
                }
                seg = next;
            } else {
                return true;
            }
        }
    }
}

struct HirRootableSegments<'a>(&'a [hir::PathSegment<'a>]);
impl TokenPat for HirRootableSegments<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let segs = if let [first, rest @ ..] = self.0
            && first.ident.name == kw::PathRoot
        {
            if !ColonColon.read_tokens(cursor) {
                return false;
            }
            rest
        } else {
            self.0
        };
        HirSegments(segs).read_tokens(cursor)
    }
}

impl TokenPat for &hir::Path<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        HirRootableSegments(self.segments).read_tokens(cursor)
    }
}

impl TokenPat for (Option<&ast::QSelf>, &ast::Path) {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if let Some(qself) = self.0 {
            if !Lt.read_tokens(cursor) {
                return false;
            }
            let Some((trait_path, path)) = self.1.segments.split_at_checked(qself.position) else {
                return true;
            };
            cursor.skip_sp(qself.ty.span).unadjusted_or_read_pat((
                SkipCParen,
                (!trait_path.is_empty()).then_some("as"),
                AstRootableSegments(trait_path),
                Gt,
                ColonColon,
                AstSegments(path),
            ))
        } else {
            self.1.read_tokens(cursor)
        }
    }
}

struct HirResolvedPath<'tcx>(Option<&'tcx hir::Ty<'tcx>>, &'tcx hir::Path<'tcx>);
impl TokenPat for HirResolvedPath<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if let Some(qself) = self.0 {
            if !Lt.read_tokens(cursor) {
                return false;
            }
            let [trait_path @ .., seg] = self.1.segments else {
                return true;
            };
            cursor.skip_sp(qself.span).unadjusted_or_read_pat((
                SkipCParen,
                "as",
                HirRootableSegments(trait_path),
                Gt,
                ColonColon,
                seg,
            ))
        } else {
            self.1.read_tokens(cursor)
        }
    }
}

impl TokenPat for &hir::QPath<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match *self {
            hir::QPath::Resolved(qself, path) => HirResolvedPath(qself, path).read_tokens(cursor),
            hir::QPath::TypeRelative(ty, seg) => cursor
                .skip_sp(ty.span)
                .unadjusted_read_tokens(OptLt)
                .adjusted_and_read_tokens((SkipCParen, OptGt, ColonColon, seg.ident)),
        }
    }
}

impl TokenPat for &ast::MacCall {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        self.path.read_tokens(cursor)
            && cursor.skip_sp(self.path.span).adjusted_and_read_tokens(Bang)
            && match self.args.delim {
                Delimiter::Brace => cursor.read_pat(OBrace),
                Delimiter::Parenthesis => cursor.read_pat(OParen),
                Delimiter::Bracket => cursor.read_pat(OBracket),
                Delimiter::Invisible(_) => true,
            }
    }
}

impl TokenPat for &ast::TraitRef {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        self.path.read_tokens(cursor)
    }
}

impl TokenPat for &hir::TraitRef<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        self.path.read_tokens(cursor)
    }
}

impl TokenPat for &ast::FnHeader {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.constness, self.coroutine_kind, self.safety, &self.ext, "fn").read_tokens(cursor)
    }
}

impl TokenPat for &hir::FnHeader {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.constness, self.asyncness, self.safety, OptExtern(&self.abi), "fn").read_tokens(cursor)
    }
}

impl TokenPat for ast::RangeLimits {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        cursor.step_single();
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        match self {
            Self::Closed => {
                cursor.step_single();
                if !matches!(cursor.next.kind, lex::TokenKind::Eq) {
                    return false;
                }
            },
            Self::HalfOpen => {},
        }
        cursor.step();
        true
    }
}

impl TokenPat for ast::RangeEnd {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        cursor.step_single();
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        match self {
            Self::Included(kind) => {
                cursor.step_single();
                if !matches!(
                    (cursor.next.kind, kind),
                    (lex::TokenKind::Dot, ast::RangeSyntax::DotDotDot)
                        | (lex::TokenKind::Eq, ast::RangeSyntax::DotDotEq)
                ) {
                    return false;
                }
            },
            Self::Excluded => {},
        }
        cursor.step();
        true
    }
}

impl TokenPat for hir::RangeEnd {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        cursor.step_single();
        if !matches!(cursor.next.kind, lex::TokenKind::Dot) {
            return false;
        }
        match self {
            Self::Included => {
                cursor.step_single();
                if !matches!(cursor.next.kind, lex::TokenKind::Eq | lex::TokenKind::Dot) {
                    return false;
                }
            },
            Self::Excluded => {},
        }
        cursor.step();
        true
    }
}

impl TokenPat for &ast::FnPtrTy {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.safety, &self.ext, "fn", OParen).read_tokens(cursor)
    }
}

impl TokenPat for &hir::FnPtrTy<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.safety, OptExtern(&self.abi), "fn", OParen).read_tokens(cursor)
    }
}

impl TokenPat for ast::Lifetime {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if matches!(cursor.next.kind, lex::TokenKind::Lifetime { .. }) && cursor.next_text() == self.ident.as_str() {
            cursor.step();
            true
        } else {
            false
        }
    }
}

impl TokenPat for &hir::Lifetime {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        let name = match self.syntax {
            hir::LifetimeSyntax::Implicit => return true,
            hir::LifetimeSyntax::ExplicitAnonymous => "'_",
            hir::LifetimeSyntax::ExplicitBound => self.ident.as_str(),
        };
        name.read_tokens(cursor)
    }
}

impl TokenPat for &ast::PolyTraitRef {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if cursor.next_text() == "for" {
            cursor.step_single();
            Lt.read_tokens(cursor)
        } else {
            (&self.modifiers, &self.trait_ref).read_tokens(cursor)
        }
    }
}

impl TokenPat for &hir::PolyTraitRef<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        if cursor.next_text() == "for" {
            cursor.step_single();
            Lt.read_tokens(cursor)
        } else {
            (&self.modifiers, &self.trait_ref).read_tokens(cursor)
        }
    }
}

impl TokenPat for &ast::GenericBound {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match self {
            ast::GenericBound::Trait(trait_) => trait_.read_tokens(cursor),
            ast::GenericBound::Outlives(lt) => lt.read_tokens(cursor),
            ast::GenericBound::Use(..) => ("use", Lt).read_tokens(cursor),
        }
    }
}

impl TokenPat for &hir::GenericBound<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        match *self {
            hir::GenericBound::Trait(trait_) => trait_.read_tokens(cursor),
            hir::GenericBound::Outlives(lt) => lt.read_tokens(cursor),
            hir::GenericBound::Use(..) => ("use", Lt).read_tokens(cursor),
        }
    }
}

impl TokenPat for &ast::Block {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.rules, OBrace).read_tokens(cursor)
    }
}

impl TokenPat for &hir::Block<'_> {
    fn read_tokens(self, cursor: &mut Cursor<'_>) -> bool {
        (self.rules, OBrace).read_tokens(cursor)
    }
}

impl Node for Ident {
    #[inline]
    fn span(self) -> Span {
        self.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(self)
    }
}

impl Node for Label {
    #[inline]
    fn span(self) -> Span {
        self.ident.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(self)
    }
}

impl Node for &Spanned<ast::LitKind> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(&self.node)
    }
}

impl Node for ast::Lifetime {
    #[inline]
    fn span(self) -> Span {
        self.ident.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(self)
    }
}

impl Node for &hir::Lifetime {
    #[inline]
    fn span(self) -> Span {
        self.ident.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(self)
    }
}

impl Node for &ast::TraitRef {
    #[inline]
    fn span(self) -> Span {
        self.path.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(self)
    }
}

impl Node for &hir::TraitRef<'_> {
    #[inline]
    fn span(self) -> Span {
        self.path.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        (!cursor.ctxt.is_root() && matches!(cursor.ctxt.outer_expn_data().kind, ExpnKind::Desugaring(_)))
            || cursor.read_pat(self)
    }
}

impl Node for &ast::Attribute {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match (&self.kind, self.style) {
            (AttrKind::DocComment(CommentKind::Block, _), AttrStyle::Inner) => cursor.read_pat(DocBlockInner),
            (AttrKind::DocComment(CommentKind::Block, _), AttrStyle::Outer) => cursor.read_pat(DocBlockOuter),
            (AttrKind::DocComment(CommentKind::Line, _), AttrStyle::Inner) => cursor.read_pat(DocLineInner),
            (AttrKind::DocComment(CommentKind::Line, _), AttrStyle::Outer) => cursor.read_pat(DocLineOuter),
            (AttrKind::Normal(attr), _) => cursor.read_pat((
                // For an attribute inside a `cfg_attr`, the span only contains the part inside the brackets.
                OptAttrStart(self.style),
                AttrSafety(attr.item.unsafety),
                &attr.item.path,
                &attr.item.args,
            )),
        }
    }
}

impl Node for &ast::Closure {
    #[inline]
    fn span(self) -> Span {
        self.fn_decl_span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat((
            &self.binder,
            self.constness,
            self.coroutine_kind,
            self.capture_clause,
            Or,
        ))
    }
}

impl Node for &hir::Closure<'_> {
    #[inline]
    fn span(self) -> Span {
        self.fn_decl_span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        if matches!(
            self.kind,
            hir::ClosureKind::Coroutine(hir::CoroutineKind::Desugared(..))
        ) {
            return true;
        }
        cursor.read_pat((self.binder, self.constness, self.kind, self.capture_clause, Or))
    }
}

impl Node for &ast::Block {
    #[inline]
    fn span(self) -> Span {
        self.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(self)
    }
}

impl Node for &hir::Block<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }
    #[inline]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        cursor.read_pat(self)
    }
}

impl Node for &ast::Expr {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    #[expect(clippy::too_many_lines)]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match self.kind {
            ast::ExprKind::AddrOf(kind, mutbl, _) => cursor.read_pat(AddrOf(kind, mutbl)),
            ast::ExprKind::Array(ref exprs) => match &**exprs {
                [] => cursor.read_pat((OBracket, CBracket)),
                [.., last] => {
                    cursor.read_pat(OBracket) && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CBracket))
                },
            },
            ast::ExprKind::Assign(_, _, sp) => cursor.sub_sp_is_other_ctxt_or_text(sp, "="),
            ast::ExprKind::AssignOp(op, ..) => cursor.sub_sp_is_other_ctxt_or_text(op.span, op.node.as_str()),
            ast::ExprKind::Await(_, sp) => cursor.sub_sp_is_other_ctxt_or_text(sp, "await"),
            ast::ExprKind::Become(_) => cursor.read_pat("become"),
            ast::ExprKind::Binary(op, ..) => cursor.sub_sp_is_other_ctxt_or_text(op.span, op.node.as_str()),
            ast::ExprKind::Block(ref b, label) => cursor.read_pat((label.map(LabeledItem), &**b)),
            ast::ExprKind::Break(label, _) => cursor.read_pat(("break", label)),
            ast::ExprKind::Call(ref callee, ref args) => {
                let mut adjusted = cursor.skip_sp(callee.span);
                adjusted.unadjusted_read_tokens(Dollar);
                match &**args {
                    [] => adjusted.unadjusted_or_read_pat((OParen, CParen)),
                    [.., last] => {
                        adjusted.unadjusted_or_read_pat(OParen)
                            && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CParen))
                    },
                }
            },
            ast::ExprKind::Cast(ref lhs, _) => cursor
                .skip_sp(lhs.span)
                .unadjusted_read_tokens(Dollar)
                .unadjusted_or_read_pat("as"),
            ast::ExprKind::Closure(ref c) => c.check_text(cursor),
            ast::ExprKind::ConstBlock(_) => cursor.read_pat(("const", OBrace)),
            ast::ExprKind::Continue(label) => cursor.read_pat(("continue", label)),
            ast::ExprKind::Field(ref base, ident) => cursor
                .skip_sp(base.span)
                .unadjusted_read_tokens(Dollar)
                .unadjusted_or_read_pat((Dot, ident)),
            ast::ExprKind::ForLoop {
                ref pat,
                ref iter,
                label,
                kind,
                ref body,
            } => {
                cursor.read_pat((label.map(LabeledItem), kind))
                    && cursor.skip_sp(pat.span).unadjusted_or_read_pat("in")
                    && cursor.skip_sp(iter.span).unadjusted_or_read_pat(&**body)
            },
            ast::ExprKind::Gen(capture, ref block, ref kind, _) => cursor.read_pat((kind, capture, &**block)),
            ast::ExprKind::If(ref cond, ref then, ref else_) => {
                cursor.read_pat("if")
                    && cursor.skip_sp(cond.span).unadjusted_or_read_pat(OBrace)
                    && (else_.is_none() || cursor.skip_sp(then.span).unadjusted_or_read_pat(("else", OBrace)))
            },
            ast::ExprKind::Index(ref base, ref idx, _) => {
                cursor
                    .skip_sp(base.span)
                    .unadjusted_read_tokens(Dollar)
                    .unadjusted_or_read_pat(OBracket)
                    && cursor.skip_sp(idx.span).unadjusted_or_read_pat(CBracket)
            },
            ast::ExprKind::Let(ref pat, ..) => {
                cursor.read_pat("let") && cursor.skip_sp(pat.span).unadjusted_or_read_pat(Eq)
            },
            ast::ExprKind::Lit(ref lit) => cursor.read_pat(lit.kind),
            ast::ExprKind::Loop(ref b, label, _) => cursor.read_pat((label.map(LabeledItem), "loop", &**b)),
            ast::ExprKind::MacCall(ref mac) => cursor.read_pat(&**mac),
            ast::ExprKind::Match(ref scrutinee, _, ast::MatchKind::Prefix) => {
                cursor.read_pat("match") && cursor.skip_sp(scrutinee.span).unadjusted_or_read_pat(OBrace)
            },
            ast::ExprKind::Match(ref scrutinee, _, ast::MatchKind::Postfix) => cursor
                .skip_sp(scrutinee.span)
                .unadjusted_read_tokens(Dollar)
                .unadjusted_or_read_pat(("match", OBrace)),
            ast::ExprKind::MethodCall(ref call) => cursor
                .skip_sp(call.receiver.span)
                .unadjusted_read_tokens(Dollar)
                .unadjusted_or_read_pat((Dot, &call.seg, OParen)),
            ast::ExprKind::Paren(ref e) => {
                cursor.read_pat(OParen) && cursor.skip_sp(e.span).unadjusted_or_read_pat(CParen)
            },
            ast::ExprKind::Path(ref qself, ref path) => cursor.read_pat((qself.as_deref(), path)),
            ast::ExprKind::Range(None, _, limits) => cursor.read_pat(limits),
            ast::ExprKind::Range(Some(ref lhs), _, limits) => cursor
                .skip_sp(lhs.span)
                .unadjusted_read_tokens(Dollar)
                .unadjusted_or_read_pat(limits),
            ast::ExprKind::Repeat(ref e, ref len) => {
                cursor.read_pat(OBracket)
                    && cursor.skip_sp(e.span).unadjusted_or_read_pat(Semi)
                    && cursor.skip_sp(len.value.span).unadjusted_or_read_pat(CBracket)
            },
            ast::ExprKind::Ret(_) => cursor.read_pat("return"),
            ast::ExprKind::Struct(ref e) => {
                cursor.read_pat((e.qself.as_deref(), &e.path))
                    && cursor.skip_sp(e.path.span).unadjusted_or_read_pat(OBrace)
            },
            ast::ExprKind::Try(ref e) => cursor
                .skip_sp(e.span)
                .unadjusted_read_tokens(Dollar)
                .unadjusted_or_read_pat(Question),
            ast::ExprKind::TryBlock(ref b) => cursor.read_pat(("try", &**b)),
            ast::ExprKind::Tup(ref exprs) => match &**exprs {
                [] => cursor.read_pat((OParen, CParen)),
                [.., last] => {
                    cursor.read_pat(OParen) && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CParen))
                },
            },
            ast::ExprKind::Unary(op, _) => cursor.read_pat(op),
            ast::ExprKind::Underscore => cursor.read_pat("_"),
            ast::ExprKind::Use(_, sp) => cursor.sub_sp_is_other_ctxt_or_text(sp, "use"),
            ast::ExprKind::While(ref cond, ref block, label) => {
                cursor.read_pat((label.map(LabeledItem), "while"))
                    && cursor.skip_sp(cond.span).unadjusted_or_read_pat(&**block)
            },
            ast::ExprKind::Yeet(_) => cursor.read_pat(("do", "yeet")),
            ast::ExprKind::Yield(ref kind) => match kind {
                ast::YieldKind::Prefix(_) => cursor.read_pat("yield"),
                ast::YieldKind::Postfix(e) => cursor
                    .skip_sp(e.span)
                    .unadjusted_read_tokens(Dollar)
                    .unadjusted_or_read_pat((Dot, "yield")),
            },
            ast::ExprKind::Dummy
            | ast::ExprKind::Err(_)
            | ast::ExprKind::FormatArgs(_)
            | ast::ExprKind::IncludedBytes(_)
            | ast::ExprKind::InlineAsm(_)
            | ast::ExprKind::OffsetOf(..)
            | ast::ExprKind::Type(..)
            | ast::ExprKind::UnsafeBinderCast(..) => true,
        }
    }
}
impl Node for &hir::Expr<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    #[expect(clippy::too_many_lines)]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        // Check for desugarings.
        if !cursor.ctxt.is_root()
            && let expn = cursor.ctxt.outer_expn_data()
            && let ExpnKind::Desugaring(kind) = expn.kind
        {
            return match kind {
                DesugaringKind::RangeExpr => match self.kind {
                    hir::ExprKind::Call(_, [lhs, _]) => {
                        cursor.ctxt = expn.call_site.ctxt();
                        cursor
                            .skip_sp(lhs.span)
                            .unadjusted_read_tokens((SkipOParen, Dollar))
                            .unadjusted_or_read_pat((SkipCParen, DotDotEq))
                    },
                    hir::ExprKind::Struct(_, [], _) => cursor.read_pat((SkipOParen, DotDot)),
                    hir::ExprKind::Struct(_, [e], _) => {
                        cursor.ctxt = expn.call_site.ctxt();
                        cursor.read_pat((SkipOParen, EitherRange))
                            || cursor
                                .skip_sp(e.span)
                                .unadjusted_read_tokens(Dollar)
                                .unadjusted_or_read_pat((SkipCParen, DotDot))
                    },
                    hir::ExprKind::Struct(_, [lhs, _], _) => {
                        cursor.ctxt = expn.call_site.ctxt();
                        cursor
                            .skip_sp(lhs.span)
                            .unadjusted_read_tokens((SkipOParen, Dollar))
                            .unadjusted_or_read_pat((SkipCParen, EitherRange))
                    },
                    _ => true,
                },
                DesugaringKind::ForLoop => match self.kind {
                    hir::ExprKind::Loop(..) | hir::ExprKind::Match(_, [_], hir::MatchSource::ForLoopDesugar) => {
                        cursor.read_pat((SkipOParen, OptLifetime, OptColon, "for"))
                    },
                    _ => true,
                },
                _ => true,
            };
        }

        match self.kind {
            hir::ExprKind::AddrOf(kind, mutbl, _) => cursor.read_pat((SkipOParen, AddrOf(kind, mutbl))),
            hir::ExprKind::Array([]) => cursor.read_pat((SkipOParen, OBracket, CBracket)),
            hir::ExprKind::Array([.., last]) => {
                cursor.read_pat((SkipOParen, OBracket))
                    && cursor
                        .skip_sp(last.span)
                        .unadjusted_or_read_pat((SkipCParen, OptComma, CBracket))
            },
            hir::ExprKind::Assign(_, _, op_sp) => cursor.sub_sp_is_other_ctxt_or_text(op_sp, "="),
            hir::ExprKind::AssignOp(op, ..) => cursor.sub_sp_is_other_ctxt_or_text(op.span, op.node.as_str()),
            hir::ExprKind::Become(..) => cursor.read_pat((SkipOParen, "become")),
            hir::ExprKind::Binary(op, ..) => cursor.sub_sp_is_other_ctxt_or_text(op.span, op.node.as_str()),
            hir::ExprKind::Block(block, label) => cursor.read_pat((SkipOParen, label.map(LabeledItem), block)),
            hir::ExprKind::Break(dest, _) => cursor.read_pat((SkipOParen, "break", dest.label)),
            hir::ExprKind::Call(callee, _) => cursor
                .skip_sp(callee.span)
                .unadjusted_read_tokens((SkipOParen, Dollar))
                .unadjusted_or_read_pat((SkipCParen, OParen)),
            hir::ExprKind::Cast(lhs, _) => cursor
                .skip_sp(lhs.span)
                .unadjusted_read_tokens((SkipOParen, Dollar))
                .unadjusted_or_read_pat((SkipCParen, "as")),
            hir::ExprKind::Closure(c) => SkipOParen.read_tokens(cursor) && c.check_text(cursor),
            hir::ExprKind::ConstBlock(..) => cursor.read_pat((SkipOParen, "const", OBrace)),
            hir::ExprKind::Continue(dest) => cursor.read_pat((SkipOParen, "continue", dest.label)),
            hir::ExprKind::DropTemps(e) => e.check_text(cursor),
            hir::ExprKind::Field(base, field) => cursor
                .skip_sp(base.span)
                .unadjusted_read_tokens((SkipOParen, Dollar))
                .unadjusted_or_read_pat((SkipCParen, Dot, field)),
            hir::ExprKind::If(_, then, else_) => {
                cursor.read_pat((SkipOParen, "if"))
                    && (else_.is_none() || cursor.skip_sp(then.span).unadjusted_or_read_pat(("else", OBrace)))
            },
            hir::ExprKind::Index(base, index, _) => {
                cursor
                    .skip_sp(base.span)
                    .unadjusted_read_tokens((SkipOParen, Dollar))
                    .unadjusted_or_read_pat((SkipCParen, OBracket))
                    && cursor
                        .skip_sp(index.span)
                        .unadjusted_or_read_pat((SkipCParen, CBracket))
            },
            hir::ExprKind::Let(let_) => {
                cursor.read_pat((SkipOParen, "let"))
                    && cursor
                        .skip_sp(let_.pat.span)
                        .unadjusted_or_read_pat((SkipCParen, let_.ty.map_or("=", |_| ":")))
            },
            hir::ExprKind::Lit(lit) => cursor.read_pat((SkipOParen, &lit)),
            hir::ExprKind::Loop(_, label, source, _) => cursor.read_pat((
                SkipOParen,
                label.map(LabeledItem),
                match source {
                    hir::LoopSource::ForLoop => "for",
                    hir::LoopSource::While => "while",
                    hir::LoopSource::Loop => "loop",
                },
            )),
            hir::ExprKind::Match(scrutinee, _, hir::MatchSource::TryDesugar(_))
                if let hir::ExprKind::Call(_, [scrutinee]) = scrutinee.kind =>
            {
                cursor
                    .skip_sp(scrutinee.span)
                    .unadjusted_read_tokens((SkipOParen, Dollar))
                    .unadjusted_or_read_pat((SkipCParen, Question))
            },
            hir::ExprKind::Match(scrutinee, _, hir::MatchSource::AwaitDesugar)
                if let hir::ExprKind::Call(_, [scrutinee]) = scrutinee.kind =>
            {
                cursor
                    .skip_sp(scrutinee.span)
                    .unadjusted_read_tokens((SkipOParen, Dollar))
                    .unadjusted_or_read_pat((SkipCParen, Dot, "await"))
            },
            hir::ExprKind::Match(scrutinee, _, hir::MatchSource::Postfix) => cursor
                .skip_sp(scrutinee.span)
                .unadjusted_read_tokens((SkipOParen, Dollar))
                .unadjusted_or_read_pat((SkipCParen, Dot, "match")),
            hir::ExprKind::Match(scrutinee, _, _) => {
                cursor.read_pat((SkipOParen, "match"))
                    && cursor
                        .skip_sp(scrutinee.span)
                        .unadjusted_or_read_pat((SkipCParen, OBrace))
            },
            hir::ExprKind::MethodCall(seg, recv, ..) => cursor
                .skip_sp(recv.span)
                .unadjusted_read_tokens((SkipOParen, Dollar))
                .unadjusted_or_read_pat((SkipCParen, Dot, seg.ident, OParen)),
            hir::ExprKind::Path(hir::QPath::Resolved(None, path))
                if let [seg] = path.segments
                    && seg.ident.span.is_dummy() =>
            {
                // Used by verious desugarings without a new context for diagnostic reasons.
                true
            },
            hir::ExprKind::Path(ref qpath) => cursor.read_pat((SkipOParen, qpath)),
            hir::ExprKind::Repeat(e, _) => {
                cursor.read_pat((SkipOParen, OBracket))
                    && cursor.skip_sp(e.span).unadjusted_or_read_pat((SkipCParen, Semi))
            },
            hir::ExprKind::Ret(..) => cursor.read_pat((SkipOParen, "return")),
            hir::ExprKind::Struct(qpath, ..) => {
                cursor.read_pat((SkipOParen, qpath))
                    && cursor.skip_sp(hir_qpath_end_sp(qpath)).unadjusted_or_read_pat(OBrace)
            },
            hir::ExprKind::Tup([]) => cursor.read_pat((OParen, SkipOParen, CParen)),
            hir::ExprKind::Tup([.., last]) => {
                cursor.read_pat(OParen) && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CParen))
            },
            hir::ExprKind::Unary(op, _) => cursor.read_pat((SkipOParen, op)),
            hir::ExprKind::Yield(..) => cursor.read_pat((SkipOParen, "yield")),
            hir::ExprKind::Err(..)
            | hir::ExprKind::InlineAsm(..)
            | hir::ExprKind::OffsetOf(..)
            | hir::ExprKind::Type(..)
            | hir::ExprKind::UnsafeBinderCast(..)
            | hir::ExprKind::Use(..) => true,
        }
    }
}

impl Node for &ast::Pat {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match self.kind {
            ast::PatKind::Box(_) => cursor.read_pat("box"),
            ast::PatKind::Expr(ref e) => e.check_text(cursor),
            ast::PatKind::Guard(ref p, _) => cursor
                .skip_sp(p.span)
                .unadjusted_read_tokens(Dollar)
                .unadjusted_or_read_pat("if"),
            ast::PatKind::Ident(mode, ident, ref p) => cursor.read_pat((mode, ident, p.is_some().then_some(At))),
            ast::PatKind::MacCall(ref mac) => cursor.read_pat(&**mac),
            ast::PatKind::Never => cursor.read_pat(Bang),
            ast::PatKind::Or(ref pats) => match &**pats {
                [first, ..] => cursor
                    .skip_sp(first.span)
                    .unadjusted_read_tokens((OptOr, Dollar))
                    .unadjusted_or_read_pat(Or),
                [] => true,
            },
            ast::PatKind::Paren(ref p) => {
                cursor.read_pat(OParen) && cursor.skip_sp(p.span).unadjusted_or_read_pat(CParen)
            },
            ast::PatKind::Path(ref qself, ref path) => cursor.read_pat((qself.as_deref(), path)),
            ast::PatKind::Range(_, _, ref op) => cursor.sub_sp_is_other_ctxt_or_text(
                op.span,
                match op.node {
                    ast::RangeEnd::Excluded => "..",
                    ast::RangeEnd::Included(ast::RangeSyntax::DotDotDot) => "...",
                    ast::RangeEnd::Included(ast::RangeSyntax::DotDotEq) => "..=",
                },
            ),
            ast::PatKind::Ref(_, kind, mutbl) => {
                cursor.read_pat((And, kind, OrConstIf(mutbl, matches!(kind, Pinnedness::Pinned))))
            },
            ast::PatKind::Rest => cursor.read_pat(DotDot),
            ast::PatKind::Slice(ref pats) => match &**pats {
                [] => cursor.read_pat((OBracket, CBracket)),
                [.., last] => {
                    cursor.read_pat(OBracket) && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CBracket))
                },
            },
            ast::PatKind::Struct(ref qself, ref path, ..) => {
                cursor.read_pat((qself.as_deref(), path)) && cursor.skip_sp(path.span).unadjusted_or_read_pat(OBrace)
            },
            ast::PatKind::Tuple(ref pats) => match &**pats {
                [] => cursor.read_pat((OParen, CParen)),
                [.., last] => {
                    cursor.read_pat(OParen) && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CParen))
                },
            },
            ast::PatKind::TupleStruct(ref qself, ref path, ..) => {
                cursor.read_pat((qself.as_deref(), path)) && cursor.skip_sp(path.span).unadjusted_or_read_pat(OParen)
            },
            ast::PatKind::Wild => cursor.read_pat("_"),
            ast::PatKind::Deref(_) | ast::PatKind::Err(_) | ast::PatKind::Missing => true,
        }
    }
}

impl Node for &hir::Pat<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match self.kind {
            // Desugarings
            hir::PatKind::Binding(BindingMode(ByRef::No, _), _, _, None)
            | hir::PatKind::Struct(_, [] | [_], None)
            | hir::PatKind::Wild
                if !cursor.ctxt.is_root()
                    && let outer = cursor.ctxt.outer_expn_data()
                    && matches!(outer.kind, ExpnKind::Desugaring(_)) =>
            {
                true
            },
            hir::PatKind::Binding(BindingMode(ByRef::No, _), _, ident, None) if ident.span.is_dummy() => {
                // Used by verious desugarings without a new context for diagnostic reasons.
                true
            },

            // Regular patterns
            hir::PatKind::Binding(mode, _, ident, p) => cursor.read_pat((SkipOParen, mode, ident, p.map(|_| At))),
            hir::PatKind::Box(..) => cursor.read_pat((SkipOParen, "box")),
            hir::PatKind::Expr(e) => e.check_text(cursor),
            hir::PatKind::Guard(p, _) => cursor
                .skip_sp(p.span)
                .unadjusted_read_tokens((SkipOParen, Dollar))
                .unadjusted_or_read_pat((SkipCParen, "if")),
            hir::PatKind::Never => cursor.read_pat((SkipOParen, Bang)),
            hir::PatKind::Or([first, ..]) => cursor
                .skip_sp(first.span)
                .unadjusted_read_tokens((SkipOParen, OptOr, Dollar))
                .unadjusted_or_read_pat((SkipCParen, Or)),
            hir::PatKind::Range(None, _, end) => cursor.read_pat((SkipOParen, end)),
            hir::PatKind::Range(Some(p), _, end) => cursor
                .skip_sp(p.span)
                .unadjusted_read_tokens((SkipOParen, Dollar))
                .unadjusted_or_read_pat((SkipCParen, end)),
            hir::PatKind::Ref(_, kind, mutbl) => cursor.read_pat((
                SkipOParen,
                And,
                kind,
                OrConstIf(mutbl, matches!(kind, Pinnedness::Pinned)),
            )),
            hir::PatKind::Slice(..) => cursor.read_pat((SkipOParen, OBracket)),
            hir::PatKind::Struct(ref qpath, ..) => {
                cursor.read_pat((SkipOParen, qpath))
                    && cursor.skip_sp(hir_qpath_end_sp(qpath)).unadjusted_or_read_pat(OBrace)
            },
            hir::PatKind::Tuple([], dd_pos) => cursor.read_pat((
                OParen,
                SkipOParen,
                dd_pos.as_opt_usize().map(|_| (DotDot, OptComma)),
                CParen,
            )),
            hir::PatKind::Tuple(pats @ [.., last], dd_pos) => {
                cursor.read_pat(OParen)
                    && match dd_pos.as_opt_usize() {
                        Some(x) if let Some(pat) = pats.get(x) => cursor
                            .skip_sp(pat.span)
                            .unadjusted_or_read_pat((SkipCParen, Comma, DotDot, Comma)),
                        Some(_) => cursor
                            .skip_sp(last.span)
                            .unadjusted_or_read_pat((SkipCParen, Comma, DotDot, CParen)),
                        None => cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CParen)),
                    }
            },
            hir::PatKind::TupleStruct(ref qpath, ..) => {
                cursor.read_pat(qpath) && cursor.skip_sp(hir_qpath_end_sp(qpath)).unadjusted_or_read_pat(OParen)
            },
            hir::PatKind::Wild => cursor.read_pat((SkipOParen, "_")),
            hir::PatKind::Err(_) | hir::PatKind::Deref(..) | hir::PatKind::Missing | hir::PatKind::Or([]) => true,
        }
    }
}

impl Node for &hir::PatExpr<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match self.kind {
            hir::PatExprKind::ConstBlock(_) => cursor.read_pat((SkipOParen, "const", OBrace)),
            hir::PatExprKind::Lit { lit, negated } => cursor.read_pat((SkipOParen, negated.then_some(Minus), &lit)),
            hir::PatExprKind::Path(ref qpath) => cursor.read_pat((SkipOParen, qpath)),
        }
    }
}

impl Node for &hir::Arm<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        if !cursor.ctxt.is_root() && matches!(cursor.ctxt.outer_expn_data().kind, ExpnKind::Desugaring(_)) {
            return true;
        }

        let mut adjusted = cursor.skip_sp(self.pat.span);
        adjusted.unadjusted_read_tokens((SkipOParen, Dollar));
        if let Some(guard) = self.guard {
            adjusted.unadjusted_or_read_pat((SkipCParen, "if"));
            adjusted = cursor.skip_sp(guard.span);
        }
        adjusted.unadjusted_or_read_pat((SkipCParen, FatArrow))
    }
}

impl Node for &hir::Item<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    #[expect(clippy::too_many_lines)]
    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        let has_vis = if self.vis_span.is_empty() {
            false
        } else if !cursor.read_pat("pub") {
            return false;
        } else {
            true
        };

        match self.kind {
            hir::ItemKind::Const(ident, generics, ty, _) => {
                (has_vis || cursor.read_pat(("const", ident)))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if generics.span.is_empty() { ":" } else { "<" })
                    && cursor.skip_sp(ty.span).unadjusted_or_read_pat((SkipCParen, Eq))
            },
            hir::ItemKind::Enum(ident, generics, _) => {
                (has_vis || cursor.read_pat(("enum", ident)))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if !generics.span.is_empty() {
                            "<"
                        } else if !generics.where_clause_span.is_empty() {
                            "where"
                        } else {
                            "{"
                        })
            },
            hir::ItemKind::ExternCrate(None, ident) => {
                (has_vis || cursor.read_pat(("extern", "crate", ident)))
                    && cursor.skip_sp(ident.span).unadjusted_or_read_pat(Semi)
            },
            hir::ItemKind::ExternCrate(Some(crate_name), ident) => {
                (has_vis || cursor.read_pat(("extern", "crate", Ident::with_dummy_span(crate_name), "as", ident)))
                    && cursor.skip_sp(ident.span).unadjusted_or_read_pat(Semi)
            },
            hir::ItemKind::Fn {
                sig, ident, generics, ..
            } => {
                (has_vis || cursor.read_pat((&sig.header, ident)))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if generics.span.is_empty() { "(" } else { "<" })
            },
            hir::ItemKind::ForeignMod { .. } => {
                has_vis || cursor.read_pat((OptText("unsafe"), "extern", OptLitStr, OBrace))
            },
            hir::ItemKind::Impl(impl_) if let Some(header) = impl_.of_trait => {
                (has_vis
                    || cursor.read_pat((
                        header.defaultness,
                        header.safety,
                        "impl",
                        match (impl_.generics.span.is_empty(), header.constness) {
                            (false, _) => Some("<"),
                            (true, hir::Constness::Const) => Some("const"),
                            (true, hir::Constness::NotConst) => None,
                        },
                    )) && cursor.skip_sp(header.trait_ref.path.span).unadjusted_or_read_pat("for"))
                    && cursor.skip_sp(impl_.self_ty.span).unadjusted_or_read_pat((
                        SkipCParen,
                        if impl_.generics.where_clause_span.is_empty() {
                            "{"
                        } else {
                            "where"
                        },
                    ))
            },
            hir::ItemKind::Impl(impl_) => {
                (has_vis || cursor.read_pat(("impl", (!impl_.generics.span.is_empty()).then_some(Lt))))
                    && cursor.skip_sp(impl_.self_ty.span).unadjusted_or_read_pat((
                        SkipCParen,
                        if impl_.generics.where_clause_span.is_empty() {
                            "{"
                        } else {
                            "where"
                        },
                    ))
            },
            hir::ItemKind::Macro(_, mac, _) if mac.macro_rules => has_vis || cursor.read_pat(("macro_rules", Bang)),
            hir::ItemKind::Macro(..) => has_vis || cursor.read_pat("macro"),
            hir::ItemKind::Mod(ident, _) => has_vis || cursor.read_pat(("mod", ident)),
            hir::ItemKind::Static(mutbl, ident, ty, _) => {
                (has_vis || cursor.read_pat(("static", mutbl.is_mut().then_some("mut"), ident, Colon)))
                    && cursor.skip_sp(ty.span).unadjusted_or_read_pat((SkipCParen, Eq))
            },
            hir::ItemKind::Struct(ident, generics, data) => {
                (has_vis || cursor.read_pat(("struct", ident)))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if !generics.span.is_empty() {
                            "<"
                        } else if matches!(data, hir::VariantData::Tuple(..)) {
                            "("
                        } else if !generics.where_clause_span.is_empty() {
                            "where"
                        } else {
                            match data {
                                hir::VariantData::Struct { .. } => "{",
                                hir::VariantData::Unit(..) => ";",
                                hir::VariantData::Tuple(..) => "(",
                            }
                        })
            },
            hir::ItemKind::Trait(constness, is_auto, safety, ident, generics, bounds, _) => {
                (has_vis
                    || cursor.read_pat((
                        matches!(constness, hir::Constness::Const).then_some("const"),
                        matches!(is_auto, hir::IsAuto::Yes).then_some("auto"),
                        safety,
                        "trait",
                        ident,
                    )))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if !generics.span.is_empty() {
                            "<"
                        } else if !bounds.is_empty() {
                            ":"
                        } else if !generics.where_clause_span.is_empty() {
                            "where"
                        } else {
                            "{"
                        })
            },
            hir::ItemKind::TraitAlias(constness, ident, generics, _) => {
                (has_vis
                    || cursor.read_pat((
                        matches!(constness, hir::Constness::Const).then_some("const"),
                        "trait",
                        ident,
                    )))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if generics.span.is_empty() { "=" } else { "<" })
            },
            hir::ItemKind::TyAlias(ident, generics, _) => {
                (has_vis || cursor.read_pat(("type", ident)))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if generics.span.is_empty() { "=" } else { "<" })
            },
            hir::ItemKind::Union(ident, generics, _) => {
                (has_vis || cursor.read_pat(("union", ident)))
                    && cursor
                        .skip_sp(ident.span)
                        .unadjusted_or_read_pat(if !generics.span.is_empty() {
                            "<"
                        } else if !generics.where_clause_span.is_empty() {
                            "where"
                        } else {
                            "{"
                        })
            },
            hir::ItemKind::GlobalAsm { .. } | hir::ItemKind::Use(..) => true,
        }
    }
}

impl Node for &hir::ImplItem<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        let has_vis = if self.vis_span().is_none_or(Span::is_empty) {
            false
        } else if !cursor.read_pat("pub") {
            return false;
        } else {
            true
        };

        match self.kind {
            hir::ImplItemKind::Const(ty, _) => {
                (has_vis || cursor.read_pat(("const", self.ident)))
                    && cursor
                        .skip_sp(self.ident.span)
                        .unadjusted_or_read_pat(if self.generics.span.is_empty() { ":" } else { "<" })
                    && cursor.skip_sp(ty.span).unadjusted_or_read_pat((SkipCParen, Eq))
            },
            hir::ImplItemKind::Fn(sig, _) => {
                (has_vis || cursor.read_pat((&sig.header, self.ident)))
                    && cursor
                        .skip_sp(self.ident.span)
                        .unadjusted_or_read_pat(if self.generics.span.is_empty() { "(" } else { "<" })
            },
            hir::ImplItemKind::Type(_) => {
                (has_vis || cursor.read_pat(("type", self.ident)))
                    && cursor
                        .skip_sp(self.ident.span)
                        .unadjusted_or_read_pat(if self.generics.span.is_empty() { "=" } else { "<" })
            },
        }
    }
}

impl Node for &hir::TraitItem<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match self.kind {
            hir::TraitItemKind::Const(ty, rhs) => {
                cursor.read_pat(("const", self.ident))
                    && cursor
                        .skip_sp(self.ident.span)
                        .unadjusted_or_read_pat(if self.generics.span.is_empty() { ":" } else { "<" })
                    && cursor
                        .skip_sp(ty.span)
                        .unadjusted_or_read_pat((SkipCParen, rhs.map(|_| Eq)))
            },
            hir::TraitItemKind::Fn(sig, _) => {
                cursor.read_pat((&sig.header, self.ident))
                    && cursor
                        .skip_sp(self.ident.span)
                        .unadjusted_or_read_pat(if self.generics.span.is_empty() { "(" } else { "<" })
            },
            hir::TraitItemKind::Type(..) => {
                cursor.read_pat(("type", self.ident))
                    && (self.generics.span.is_empty() || cursor.skip_sp(self.ident.span).unadjusted_or_read_pat(Lt))
            },
        }
    }
}

impl Node for &hir::ForeignItem<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        let has_vis = if self.vis_span.is_empty() {
            false
        } else if !cursor.read_pat("pub") {
            return false;
        } else {
            true
        };

        match self.kind {
            hir::ForeignItemKind::Fn(sig, _, generics) => {
                (has_vis || cursor.read_pat((&sig.header, self.ident)))
                    && cursor
                        .skip_sp(self.ident.span)
                        .unadjusted_or_read_pat(if generics.span.is_empty() { "(" } else { "<" })
            },
            hir::ForeignItemKind::Static(_, mutbl, safety) => {
                (has_vis || cursor.read_pat((safety, "static", mutbl.is_mut().then_some("mut"), self.ident)))
                    && cursor.skip_sp(self.ident.span).unadjusted_or_read_pat(Colon)
            },
            hir::ForeignItemKind::Type => has_vis || cursor.read_pat(("type", self.ident)),
        }
    }
}

impl Node for &ast::Ty {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match &self.kind {
            ast::TyKind::Array(ty, len) => {
                cursor.read_pat(OBracket)
                    && cursor.skip_sp(ty.span).unadjusted_or_read_pat(Semi)
                    && cursor.skip_sp(len.value.span).unadjusted_or_read_pat(CBracket)
            },
            ast::TyKind::FnPtr(ty) => cursor.read_pat(&**ty),
            ast::TyKind::ImplTrait(..) => cursor.read_pat("impl"),
            ast::TyKind::Infer => cursor.read_pat(AnyIdent),
            ast::TyKind::MacCall(mac) => cursor.read_pat((&mac.path, Bang)),
            ast::TyKind::Never => cursor.read_pat(Bang),
            ast::TyKind::Paren(ty) => cursor.read_pat(OParen) && cursor.skip_sp(ty.span).unadjusted_or_read_pat(CParen),
            ast::TyKind::Path(qself, path) => cursor.read_pat((qself.as_deref(), path)),
            &ast::TyKind::PinnedRef(lt, ref ty) => cursor.read_pat((And, lt, OrConst(ty.mutbl))),
            ast::TyKind::Ptr(ty) => cursor.read_pat((Star, OrConst(ty.mutbl))),
            &ast::TyKind::Ref(lt, ref ty) => cursor.read_pat((And, lt, ty.mutbl)),
            ast::TyKind::Slice(ty) => {
                cursor.read_pat(OBracket) && cursor.skip_sp(ty.span).unadjusted_or_read_pat(CBracket)
            },
            &ast::TyKind::TraitObject(ref bounds, syntax) => cursor.read_pat((syntax, bounds.first())),
            ast::TyKind::Tup(tys) if let [.., last] = &**tys => {
                cursor.read_pat(OParen) && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CParen))
            },
            ast::TyKind::Tup(_) => cursor.read_pat((OParen, CParen)),
            ast::TyKind::UnsafeBinder(..) => cursor.read_pat("unsafe"),
            ast::TyKind::CVarArgs
            | ast::TyKind::Dummy
            | ast::TyKind::Err(_)
            | ast::TyKind::ImplicitSelf
            | ast::TyKind::Pat(..)
            | ast::TyKind::Typeof(_) => true,
        }
    }
}

impl Node for &hir::Ty<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        match self.kind {
            hir::TyKind::Tup([]) if self.span.is_empty() => true,
            hir::TyKind::OpaqueDef(_) | hir::TyKind::Path(_)
                if !cursor.ctxt.is_root()
                    && let expn = cursor.ctxt.outer_expn_data()
                    && matches!(expn.kind, ExpnKind::Desugaring(_)) =>
            {
                true
            },

            hir::TyKind::Array(ty, _) => {
                cursor.read_pat((SkipOParen, OBracket))
                    && cursor.skip_sp(ty.span).unadjusted_or_read_pat((SkipCParen, Semi))
            },
            hir::TyKind::FnPtr(ty) => cursor.read_pat((SkipOParen, ty)),
            hir::TyKind::Infer(()) => cursor.read_pat((SkipOParen, "_")),
            hir::TyKind::Never => cursor.read_pat((SkipOParen, "!")),
            hir::TyKind::OpaqueDef(_) | hir::TyKind::TraitAscription(_) => cursor.read_pat((SkipOParen, "impl")),
            hir::TyKind::Path(ref qpath) => cursor.read_pat((SkipOParen, qpath)),
            hir::TyKind::Ptr(ty) => cursor.read_pat((SkipOParen, Star, OrConst(ty.mutbl))),
            hir::TyKind::Ref(lt, ty) => cursor.read_pat((SkipOParen, And, lt, ty.mutbl)),
            hir::TyKind::Slice(ty) => {
                cursor.read_pat((SkipOParen, OBracket))
                    && cursor.skip_sp(ty.span).unadjusted_or_read_pat((SkipCParen, CBracket))
            },
            hir::TyKind::TraitObject(bounds, tagged) => {
                cursor.read_pat((SkipOParen, tagged.tag(), Any((Lifetime, bounds.first()))))
            },
            hir::TyKind::Tup([]) => cursor.read_pat((OParen, SkipOParen, CParen)),
            hir::TyKind::Tup([.., last]) => {
                cursor.read_pat(OParen) && cursor.skip_sp(last.span).unadjusted_or_read_pat((OptComma, CParen))
            },
            hir::TyKind::UnsafeBinder(..) => cursor.read_pat((SkipOParen, "unsafe", Lt)),
            hir::TyKind::Err(_) | hir::TyKind::InferDelegation(..) | hir::TyKind::Pat(..) | hir::TyKind::Typeof(_) => {
                true
            },
        }
    }
}

impl Node for &hir::FieldDef<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        let has_vis = if self.vis_span.is_empty() {
            false
        } else if !cursor.read_pat("pub") {
            return false;
        } else {
            true
        };

        if self.is_positional() {
            has_vis || self.ty.span.ctxt() != cursor.ctxt || self.ty.check_text(cursor)
        } else {
            has_vis || cursor.read_pat((self.ident, Colon))
        }
    }
}

impl Node for &hir::Variant<'_> {
    #[inline]
    fn span(self) -> Span {
        self.span
    }

    fn check_text(self, cursor: &mut Cursor<'_>) -> bool {
        if !cursor.read_pat(self.ident) {
            return false;
        }
        match self.data {
            hir::VariantData::Struct { .. } => cursor.read_pat(OBrace),
            hir::VariantData::Tuple(..) => cursor.read_pat(OParen),
            hir::VariantData::Unit(..) => true,
        }
    }
}
