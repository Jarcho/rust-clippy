#![warn(clippy::match_single_binding)]
#![allow(
    unused,
    clippy::let_unit_value,
    clippy::no_effect,
    clippy::toplevel_ref_arg,
    clippy::uninlined_format_args,
    clippy::useless_vec
)]

struct Point {
    x: i32,
    y: i32,
}

fn coords() -> Point {
    Point { x: 1, y: 2 }
}

macro_rules! foo {
    ($param:expr) => {
        match $param {
            _ => println!("whatever"),
        }
    };
}

fn main() {
    let a = 1;
    let b = 2;
    let c = 3;
    // Lint
    //~v match_single_binding
    let (x, y, z) = (a, b, c);
    {
        println!("{} {} {}", x, y, z);
    }
    // Lint
    //~v match_single_binding
    let (x, y, z) = (a, b, c);
    println!("{} {} {}", x, y, z);
    // Ok
    foo!(a);
    // Ok
    match a {
        2 => println!("2"),
        _ => println!("Not 2"),
    }
    // Ok
    let d = Some(5);
    match d {
        Some(d) => println!("{}", d),
        _ => println!("None"),
    }
    // Lint
    //~v match_single_binding
    println!("whatever");
    // Lint
    //~v match_single_binding
    {
        let x = 29;
        println!("x has a value of {}", x);
    }
    // Lint
    //~v match_single_binding
    {
        let e = 5 * a;
        if e >= 5 {
            println!("e is superior to 5");
        }
    }
    // Lint
    let p = Point { x: 0, y: 7 };
    //~v match_single_binding
    let Point { x, y } = p;
    println!("Coords: ({}, {})", x, y);
    // Lint
    //~v match_single_binding
    let Point { x: x1, y: y1 } = p;
    println!("Coords: ({}, {})", x1, y1);
    // Lint
    let x = 5;
    //~v match_single_binding
    let ref r = x;
    println!("Got a reference to {}", r);
    // Lint
    let mut x = 5;
    //~v match_single_binding
    let ref mut mr = x;
    println!("Got a mutable reference to {}", mr);
    // Lint
    //~v match_single_binding
    let Point { x, y } = coords();
    let product = x * y;
    // Lint
    let v = vec![Some(1), Some(2), Some(3), Some(4)];
    #[allow(clippy::let_and_return)]
    let _ = v
        .iter()
        //~v match_single_binding
        .map(|i| {
            let unwrapped = i.unwrap();
            unwrapped
        })
        .collect::<Vec<u8>>();
    // Ok
    let x = 1;
    match x {
        #[cfg(disabled_feature)]
        0 => println!("Disabled branch"),
        _ => println!("Enabled branch"),
    }

    // Ok
    let x = 1;
    let y = 1;
    match match y {
        0 => 1,
        _ => 2,
    } {
        #[cfg(disabled_feature)]
        0 => println!("Array index start"),
        _ => println!("Not an array index start"),
    }

    // Lint
    let x = 1;
    //~v match_single_binding
    println!("Not an array index start")
}

fn issue_8723() {
    let (mut val, idx) = ("a b", 1);

    //~v match_single_binding
    let (pre, suf) = val.split_at(idx);
    val = {
        println!("{}", pre);
        suf
    };

    let _ = val;
}

fn side_effects() {}

fn issue_9575() {
    //~v match_single_binding
    let _ = || {
        side_effects();
        println!("Needs curlies")
    };
}

fn issue_9725(r: Option<u32>) {
    //~v match_single_binding
    let x = r;
    match x {
        Some(_) => {
            println!("Some");
        },
        None => {
            println!("None");
        },
    };
}

fn issue_10447() -> usize {
    //~v match_single_binding
    ();

    //~v match_single_binding
    let a = ();

    //~v match_single_binding
    side_effects();

    //~v match_single_binding
    let b = side_effects();

    //~v match_single_binding
    println!("1");

    //~v match_single_binding
    let c = println!("1");

    let in_expr = [
        //~v match_single_binding
        (),
        //~v match_single_binding
        side_effects(),
        //~v match_single_binding
        println!("1"),
    ];

    2
}
