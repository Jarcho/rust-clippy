use crate::parse::{Lint, ParsedData};
use crate::utils::{FileUpdater, UpdateMode, UpdateStatus, update_text_region_fn};
use itertools::Itertools;
use std::fmt::Write;
use std::path::Path;

const GENERATED_FILE_COMMENT: &str = "// This file was generated by `cargo dev update_lints`.\n\
     // Use that command to update this file and do not edit by hand.\n\
     // Manual edits will be overwritten.\n\n";

const DOCS_LINK: &str = "https://rust-lang.github.io/rust-clippy/master/index.html";

/// Runs the `update_lints` command.
///
/// This updates various generated values from the lint source code.
///
/// `update_mode` indicates if the files should be updated or if updates should be checked for.
///
/// # Panics
///
/// Panics if a file path could not read from or then written to
pub fn update(update_mode: UpdateMode) {
    generate_lint_files(update_mode, &ParsedData::collect());
}

#[expect(clippy::too_many_lines)]
pub fn generate_lint_files(update_mode: UpdateMode, data: &ParsedData) {
    let mut updater = FileUpdater::default();

    let mut lints: Vec<_> = data.lints.iter().map(|(x, y)| (&**x, y)).collect();
    lints.sort_by_key(|&(x, _)| x);

    updater.update_file_checked(
        "cargo dev update_lints",
        update_mode,
        "CHANGELOG.md",
        &mut update_text_region_fn(
            "<!-- begin autogenerated links to lint list -->\n",
            "<!-- end autogenerated links to lint list -->",
            |dst| {
                for &(lint, _) in &lints {
                    writeln!(dst, "[`{lint}`]: {DOCS_LINK}#{lint}").unwrap();
                }
            },
        ),
    );

    let mut active = Vec::with_capacity(data.lints.len());
    let mut deprecated = Vec::with_capacity(data.lints.len());
    let mut renamed = Vec::with_capacity(data.lints.len());
    for (name, lint) in lints {
        match lint {
            Lint::Active(lint) => active.push((name, &data.source_map.files[lint.span.file])),
            Lint::Deprecated(lint) => deprecated.push((name, lint)),
            Lint::Renamed(lint) => renamed.push((name, lint)),
        }
    }
    active.sort_by(|(_, x), (_, y)| (x.krate, &*x.module).cmp(&(y.krate, &*y.module)));

    // Round the lint count down to avoid merge conflicts every time a new lint is added.
    let lint_count = active.len() / 50 * 50;
    updater.update_file_checked(
        "cargo dev update_lints",
        update_mode,
        "README.md",
        &mut update_text_region_fn("[There are over ", " lints included in this crate!]", |dst| {
            write!(dst, "{lint_count}").unwrap();
        }),
    );
    updater.update_file_checked(
        "cargo dev update_lints",
        update_mode,
        "book/src/README.md",
        &mut update_text_region_fn("[There are over ", " lints included in this crate!]", |dst| {
            write!(dst, "{lint_count}").unwrap();
        }),
    );

    updater.update_file_checked(
        "cargo dev update_lints",
        update_mode,
        "clippy_lints/src/deprecated_lints.rs",
        &mut |_, src, dst| {
            dst.push_str(&src[..data.deprecated_span.start as usize]);
            for &(name, lint) in &deprecated {
                write!(
                    dst,
                    "\n    #[clippy::version = \"{}\"]\n    (\"clippy::{name}\", \"{}\"),",
                    lint.version, lint.reason,
                )
                .unwrap();
            }
            dst.push_str(&src[data.deprecated_span.end as usize..data.renamed_span.start as usize]);
            for &(name, lint) in &renamed {
                write!(
                    dst,
                    "\n    #[clippy::version = \"{}\"]\n    (\"clippy::{name}\", \"{}\"),",
                    lint.version, lint.new_name,
                )
                .unwrap();
            }
            dst.push_str(&src[data.renamed_span.end as usize..]);
            UpdateStatus::from_changed(src != dst)
        },
    );
    updater.update_file_checked(
        "cargo dev update_lints",
        update_mode,
        "tests/ui/deprecated.rs",
        &mut |_, src, dst| {
            dst.push_str(GENERATED_FILE_COMMENT);
            for &(name, _) in &deprecated {
                writeln!(dst, "#![warn(clippy::{name})] //~ ERROR: lint `clippy::{name}`").unwrap();
            }
            dst.push_str("\nfn main() {}\n");
            UpdateStatus::from_changed(src != dst)
        },
    );
    updater.update_file_checked(
        "cargo dev update_lints",
        update_mode,
        "tests/ui/rename.rs",
        &mut move |_, src, dst| {
            dst.push_str(GENERATED_FILE_COMMENT);
            dst.push_str("#![allow(clippy::duplicated_attributes)]\n");
            for &(name, _) in &renamed {
                writeln!(dst, "#![warn(clippy::{name})] //~ ERROR: lint `clippy::{name}`").unwrap();
            }
            dst.push_str("\nfn main() {}\n");
            UpdateStatus::from_changed(src != dst)
        },
    );

    let mut active = &*active;
    while let [(_, first_lint), ..] = active {
        let (crate_lints, tail) = active.split_at(active.partition_point(|(_, x)| x.krate == first_lint.krate));
        let krate_name = &*data.source_map.crates[first_lint.krate];
        active = tail;

        updater.update_file_checked(
            "cargo dev update_lints",
            update_mode,
            Path::new(krate_name).join("src/lib.rs"),
            &mut update_text_region_fn(
                "// begin lints modules, do not remove this comment, it's used in `update_lints`\n",
                "// end lints modules, do not remove this comment, it's used in `update_lints`",
                |dst| {
                    for (_, lint) in crate_lints.iter().dedup_by(|(_, x), (_, y)| x.module == y.module) {
                        if !lint.module.is_empty() {
                            writeln!(dst, "mod {};", lint.module).unwrap();
                        }
                    }
                },
            ),
        );
        updater.update_file_checked(
            "cargo dev update_lints",
            update_mode,
            Path::new(krate_name).join("src/declared_lints.rs"),
            &mut |_, src, dst| {
                dst.push_str(GENERATED_FILE_COMMENT);
                dst.push_str("pub static LINTS: &[&::declare_clippy_lint::LintInfo] = &[\n");
                let mut buf = String::new();
                for (name, lint) in crate_lints {
                    buf.clear();
                    buf.push_str(name);
                    buf.make_ascii_uppercase();
                    if lint.module.is_empty() {
                        writeln!(dst, "    crate::{buf}_INFO,").unwrap();
                    } else {
                        writeln!(dst, "    crate::{}::{buf}_INFO,", lint.module).unwrap();
                    }
                }
                dst.push_str("];\n");
                UpdateStatus::from_changed(src != dst)
            },
        );
    }
}
